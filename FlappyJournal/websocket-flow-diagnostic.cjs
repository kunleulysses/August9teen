#!/usr/bin/env node

/**
 * WebSocket Flow Diagnostic Tool
 * Identifies exactly where the message flow is breaking
 */

const WebSocket = require('ws');

console.log('üîß WEBSOCKET FLOW DIAGNOSTIC TOOL');
console.log('üéØ Identifying exact breakpoint in message flow');

class WebSocketFlowDiagnostic {
    constructor() {
        this.testResults = {
            connectionEstablished: false,
            initialResponseReceived: false,
            chatMessageSent: false,
            selfCodingRequestSent: false,
            responseTypesReceived: new Set(),
            debugLogsDetected: false,
            performanceOptimizerActive: false,
            messageHandlerCalled: false
        };
    }

    async runDiagnostic() {
        console.log('\nüì° Step 1: Establishing WebSocket connection...');
        
        return new Promise((resolve) => {
            const ws = new WebSocket('ws://localhost:3002');
            let testPhase = 0;
            
            ws.on('open', () => {
                console.log('‚úÖ WebSocket connection established');
                this.testResults.connectionEstablished = true;
                
                // Step 2: Wait for initial response
                console.log('\nüì° Step 2: Waiting for initial connection response...');
            });

            ws.on('message', (data) => {
                try {
                    const response = JSON.parse(data);
                    this.testResults.responseTypesReceived.add(response.type);
                    
                    if (response.type === 'unified_connection_established') {
                        console.log('‚úÖ Initial connection response received');
                        this.testResults.initialResponseReceived = true;
                        
                        // Step 3: Send a simple chat message
                        setTimeout(() => {
                            console.log('\nüì° Step 3: Sending simple chat message...');
                            const chatMessage = {
                                type: 'chat',
                                message: 'Hello',
                                content: 'Hello',
                                timestamp: Date.now()
                            };
                            console.log('   Message:', JSON.stringify(chatMessage));
                            ws.send(JSON.stringify(chatMessage));
                            this.testResults.chatMessageSent = true;
                        }, 2000);
                        
                        // Step 4: Send self-coding request
                        setTimeout(() => {
                            console.log('\nüì° Step 4: Sending self-coding request...');
                            const selfCodingMessage = {
                                type: 'self_coding_request',
                                request: {
                                    purpose: 'diagnostic-test',
                                    type: 'function',
                                    language: 'javascript',
                                    description: 'Generate a simple test function'
                                },
                                timestamp: Date.now()
                            };
                            console.log('   Message:', JSON.stringify(selfCodingMessage));
                            ws.send(JSON.stringify(selfCodingMessage));
                            this.testResults.selfCodingRequestSent = true;
                        }, 4000);
                        
                        // Step 5: Close connection and analyze
                        setTimeout(() => {
                            console.log('\nüì° Step 5: Closing connection and analyzing results...');
                            ws.close();
                        }, 8000);
                    }
                    
                    // Analyze response types
                    if (response.type === 'response') {
                        console.log('‚úÖ RESPONSE TYPE DETECTED: response');
                        console.log(`   Content: ${response.content?.substring(0, 100)}...`);
                        this.testResults.messageHandlerCalled = true;
                    }
                    
                    if (response.type === 'consciousness_response') {
                        console.log('‚úÖ RESPONSE TYPE DETECTED: consciousness_response');
                        if (response.aiResponse) {
                            console.log(`   AI Response: ${response.aiResponse.substring(0, 100)}...`);
                        }
                        this.testResults.messageHandlerCalled = true;
                    }
                    
                    if (response.type === 'self_coding_progress') {
                        console.log('‚úÖ RESPONSE TYPE DETECTED: self_coding_progress');
                        console.log(`   Status: ${response.status}, Progress: ${response.progress}%`);
                    }
                    
                    if (response.type === 'api_synthesis_success') {
                        console.log('‚úÖ RESPONSE TYPE DETECTED: api_synthesis_success');
                        console.log(`   Model: ${response.model}, Strategy: ${response.strategy}`);
                        this.testResults.performanceOptimizerActive = true;
                    }
                    
                    if (response.type === 'module_activity') {
                        // Don't log every module activity to avoid spam
                        if (!this.testResults.performanceOptimizerActive) {
                            this.testResults.performanceOptimizerActive = true;
                            console.log('‚úÖ Module activity detected - performance optimizer active');
                        }
                    }
                    
                } catch (error) {
                    console.log('üì® Non-JSON response received');
                }
            });

            ws.on('error', (err) => {
                console.error('‚ùå WebSocket error:', err.message);
            });

            ws.on('close', () => {
                console.log('\nüîö WebSocket connection closed');
                this.generateDiagnosticReport();
                resolve(this.testResults);
            });
        });
    }

    generateDiagnosticReport() {
        console.log('\n' + '='.repeat(80));
        console.log('üîß WEBSOCKET FLOW DIAGNOSTIC REPORT');
        console.log('='.repeat(80));
        
        console.log('\nüìä CONNECTION FLOW:');
        console.log(`   1. Connection Established: ${this.testResults.connectionEstablished ? '‚úÖ' : '‚ùå'}`);
        console.log(`   2. Initial Response Received: ${this.testResults.initialResponseReceived ? '‚úÖ' : '‚ùå'}`);
        console.log(`   3. Chat Message Sent: ${this.testResults.chatMessageSent ? '‚úÖ' : '‚ùå'}`);
        console.log(`   4. Self-Coding Request Sent: ${this.testResults.selfCodingRequestSent ? '‚úÖ' : '‚ùå'}`);
        
        console.log('\nüìä MESSAGE PROCESSING:');
        console.log(`   Performance Optimizer Active: ${this.testResults.performanceOptimizerActive ? '‚úÖ' : '‚ùå'}`);
        console.log(`   Message Handler Called: ${this.testResults.messageHandlerCalled ? '‚úÖ' : '‚ùå'}`);
        console.log(`   Debug Logs Detected: ${this.testResults.debugLogsDetected ? '‚úÖ' : '‚ùå'}`);
        
        console.log('\nüìä RESPONSE TYPES RECEIVED:');
        if (this.testResults.responseTypesReceived.size > 0) {
            Array.from(this.testResults.responseTypesReceived).forEach(type => {
                console.log(`   - ${type}`);
            });
        } else {
            console.log('   ‚ùå No responses received');
        }
        
        console.log('\nüîç DIAGNOSTIC ANALYSIS:');
        
        if (!this.testResults.connectionEstablished) {
            console.log('   ‚ùå CRITICAL: WebSocket connection failed');
            console.log('      ‚Üí Check if service is running on port 3002');
            console.log('      ‚Üí Verify WebSocket server initialization');
        } else if (!this.testResults.initialResponseReceived) {
            console.log('   ‚ùå CRITICAL: No initial response received');
            console.log('      ‚Üí WebSocket server not responding');
            console.log('      ‚Üí Check WebSocket connection handler');
        } else if (!this.testResults.performanceOptimizerActive) {
            console.log('   ‚ùå CRITICAL: Performance optimizer not active');
            console.log('      ‚Üí Messages not reaching performance optimizer');
            console.log('      ‚Üí Check message routing pipeline');
        } else if (!this.testResults.messageHandlerCalled) {
            console.log('   ‚ùå CRITICAL: Message handlers not called');
            console.log('      ‚Üí Messages being batched instead of processed immediately');
            console.log('      ‚Üí Check performance optimizer priority configuration');
            console.log('      ‚Üí Verify handleWebSocketMessage implementation');
        } else {
            console.log('   ‚úÖ All systems functioning correctly');
        }
        
        console.log('\nüéØ RECOMMENDED ACTIONS:');
        
        if (this.testResults.responseTypesReceived.has('response') && !this.testResults.responseTypesReceived.has('consciousness_response')) {
            console.log('   1. ‚úÖ Chat messages ARE being processed (response type detected)');
            console.log('   2. üîß Update test expectations to look for "response" instead of "consciousness_response"');
        }
        
        if (this.testResults.responseTypesReceived.has('api_synthesis_success')) {
            console.log('   3. ‚úÖ AI synthesis is working correctly');
        }
        
        if (this.testResults.performanceOptimizerActive && !this.testResults.messageHandlerCalled) {
            console.log('   4. üîß Check if HIGH priority messages are being batched incorrectly');
            console.log('   5. üîß Add more debug logging to performance optimizer');
        }
        
        if (!this.testResults.responseTypesReceived.has('self_coding_progress')) {
            console.log('   6. üîß Investigate SelfCodingProgressTracker event broadcasting');
            console.log('   7. üîß Check handleSelfCodingRequest implementation');
        }
        
        console.log('\n' + '='.repeat(80));
    }
}

// Run the diagnostic
const diagnostic = new WebSocketFlowDiagnostic();
diagnostic.runDiagnostic().then(() => {
    console.log('üèÅ WebSocket flow diagnostic complete');
}).catch(error => {
    console.error('‚ùå Diagnostic failed:', error);
});
