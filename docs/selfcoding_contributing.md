# Self-Coding System Contributing Guide

## Table of Contents
- [Development Setup](#development-setup)
- [Adding Generation Templates](#adding-generation-templates)
- [Writing Unit Tests](#writing-unit-tests)
- [Coding Conventions](#coding-conventions)
- [Prometheus Metrics](#prometheus-metrics)
- [Documentation](#documentation)

## Development Setup

### Prerequisites
- Node.js 18+ with npm
- PostgreSQL 13+
- Docker (optional, for local stack)

### Quick Start
```bash
# Clone and install
git clone <repository>
cd selfcoding-system
npm install

# Setup environment
cp .env.example .env
# Edit .env with your database URL and API keys

# Run tests
npm test

# Start development server
npm run dev
```

## Adding Generation Templates

### Template Structure

Templates are located in `consciousness/templates/` and follow this structure:

```javascript
// consciousness/templates/MyNewTemplate.cjs
const { child: getLogger } = require('../utils/logger.cjs');
const log = getLogger({ module: 'MyNewTemplate' });

class MyNewTemplate {
    constructor() {
        this.name = 'MyNewTemplate';
        this.description = 'Generates custom functionality';
        this.category = 'utility'; // utility, service, module, etc.
    }

    /**
     * Generate code based on the request
     * @param {Object} request - Generation request
     * @param {string} request.purpose - What the code should do
     * @param {string} request.language - Target language (default: javascript)
     * @param {Object} request.context - Additional context
     * @returns {Promise<string>} Generated code
     */
    async generate(request) {
        const { purpose, language = 'javascript', context = {} } = request;
        
        log.info({ purpose, language }, 'Generating code with MyNewTemplate');
        
        // Your generation logic here
        const code = this.buildCode(purpose, context);
        
        log.info({ codeLength: code.length }, 'Code generation completed');
        return code;
    }

    buildCode(purpose, context) {
        return `
// Generated by MyNewTemplate
// Purpose: ${purpose}

function generatedFunction() {
    console.log('Generated functionality for: ${purpose}');
    return true;
}

module.exports = generatedFunction;
        `.trim();
    }
}

module.exports = MyNewTemplate;
```

### Registering Templates

Add your template to the template registry:

```javascript
// consciousness/services/CodeGenerationService.cjs
const MyNewTemplate = require('../templates/MyNewTemplate.cjs');

// In the constructor or initialization method
this.templates.set('my-new-template', new MyNewTemplate());
```

### Template Best Practices

1. **Always use structured logging** with the logger utility
2. **Include trace IDs** in all log messages (automatic with getLogger)
3. **Validate inputs** and provide meaningful error messages
4. **Generate clean, readable code** with proper formatting
5. **Include comments** in generated code explaining purpose
6. **Handle edge cases** gracefully

## Writing Unit Tests

### Test Location
- Place tests in `__tests__/` directories next to the code being tested
- Use descriptive filenames: `MyNewTemplate.test.js`

### Test Structure

```javascript
// consciousness/templates/__tests__/MyNewTemplate.test.js
const MyNewTemplate = require('../MyNewTemplate.cjs');

describe('MyNewTemplate', () => {
    let template;

    beforeEach(() => {
        template = new MyNewTemplate();
    });

    test('should generate basic function', async () => {
        const request = {
            purpose: 'test functionality',
            language: 'javascript'
        };

        const code = await template.generate(request);
        
        expect(code).toContain('function generatedFunction');
        expect(code).toContain('test functionality');
        expect(code).toContain('module.exports');
    });

    test('should handle missing purpose gracefully', async () => {
        const request = { language: 'javascript' };
        
        await expect(template.generate(request)).rejects.toThrow();
    });

    test('should include proper logging', async () => {
        const logSpy = jest.spyOn(console, 'log').mockImplementation();
        
        await template.generate({ purpose: 'test' });
        
        // Verify structured logging occurred
        expect(logSpy).toHaveBeenCalled();
        logSpy.mockRestore();
    });
});
```

### Running Tests

```bash
# Run all tests
npm test

# Run specific test file
npx jest MyNewTemplate.test.js

# Run tests with coverage
npm run test:coverage

# Run tests in watch mode
npm run test:watch
```

### Jest Configuration

Tests use the configuration in `jest.config.js`:

```javascript
module.exports = {
    testEnvironment: 'node',
    testMatch: ['**/__tests__/**/*.test.js'],
    collectCoverageFrom: [
        'consciousness/**/*.cjs',
        '!consciousness/**/__tests__/**',
        '!consciousness/**/node_modules/**'
    ],
    coverageThreshold: {
        global: {
            branches: 80,
            functions: 80,
            lines: 80,
            statements: 80
        }
    }
};
```

## Coding Conventions

### Pino Logger Usage

**Always use the structured logger:**

```javascript
// ‚úÖ Correct
const { child: getLogger } = require('../utils/logger.cjs');
const log = getLogger({ module: 'MyModule' });

log.info({ userId: 123, action: 'create' }, 'User action performed');
log.warn({ error: err.message, filePath }, 'File processing failed');
log.error({ traceId, stack: err.stack }, 'Critical error occurred');

// ‚ùå Incorrect
console.log('Something happened');
console.error('Error:', error);
```

### Trace ID Propagation

**Always propagate trace IDs:**

```javascript
// ‚úÖ Correct - trace ID automatically included by getLogger
const log = getLogger({ module: 'MyService', traceId: req.traceId });
log.info({ operation: 'process' }, 'Starting operation');

// ‚úÖ Correct - manual trace ID in context
log.info({ traceId: 'abc123', userId: 456 }, 'Processing user request');

// ‚ùå Incorrect - no trace context
log.info('Processing something');
```

### Error Handling

```javascript
// ‚úÖ Correct
try {
    await riskyOperation();
} catch (error) {
    log.error({ 
        error: error.message, 
        stack: error.stack,
        operation: 'riskyOperation'
    }, 'Operation failed');
    throw error; // Re-throw if needed
}

// ‚ùå Incorrect
try {
    await riskyOperation();
} catch (error) {
    console.error('Error:', error);
}
```

### File Naming

- Use `.cjs` extension for CommonJS modules
- Use `.mjs` extension for ES modules
- Use PascalCase for class files: `CodeGenerationService.cjs`
- Use camelCase for utility files: `quotaStore.cjs`
- Use kebab-case for test files: `code-generation.test.js`

## Prometheus Metrics

### Counter vs Gauge

**Use Counters for:**
- Events that only increase: `code_generation_total`
- Error counts: `sandbox_timeouts_total`
- Request counts: `api_requests_total`

**Use Gauges for:**
- Current state: `active_generations`
- Resource usage: `memory_usage_bytes`
- Queue sizes: `pending_jobs`

### Adding New Metrics

```javascript
// consciousness/metrics/extraMetrics.cjs
const { Counter, Gauge } = require('prom-client');

// Counter example
const myOperationCounter = new Counter({
    name: 'my_operation_total',
    help: 'Total number of my operations',
    labelNames: ['status', 'type']
});

// Gauge example
const myResourceGauge = new Gauge({
    name: 'my_resource_current',
    help: 'Current amount of my resource',
    labelNames: ['resource_type']
});

// Usage
myOperationCounter.inc({ status: 'success', type: 'generation' });
myResourceGauge.set({ resource_type: 'memory' }, 1024);

module.exports = {
    myOperationCounter,
    myResourceGauge
};
```

### Metric Naming Conventions

- Use snake_case: `code_generation_failures_total`
- Include units in name: `response_time_seconds`
- Use descriptive suffixes:
  - `_total` for counters
  - `_current` for current state gauges
  - `_bytes` for byte measurements
  - `_seconds` for time measurements

## Documentation

### Generating Documentation

```bash
# Generate API documentation (if available)
npm run docgen

# Generate coverage reports
npm run test:coverage

# Lint documentation
npx markdownlint docs/
```

### Documentation Standards

- Use clear, concise language
- Include code examples for all APIs
- Document all environment variables
- Provide troubleshooting sections
- Keep documentation up-to-date with code changes

### Commit Message Format

```
type(scope): description

feat(templates): add new AI generation template
fix(sandbox): resolve memory leak in isolation
docs(ops): update monitoring handbook
test(quota): add integration tests for quota store
```

### Pull Request Checklist

- [ ] Tests pass locally
- [ ] Code follows style guidelines
- [ ] Documentation updated
- [ ] Metrics added for new features
- [ ] Security scan passes
- [ ] Performance impact assessed

---

**Happy Coding!** üöÄ

For questions or support, reach out to the Self-Coding team or create an issue in the repository.
